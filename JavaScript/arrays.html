<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>javaScript - Métodos de Arrays</h1>

    <script>
function exIndices(){
// Os elementos dentro de um Array sempre são contados começando pelo número 0. Sendo assim:
        let arr = [1, 2, 3, 4, 5]
        //índices= 0  1  2  3  4
    }
    
function exLength(){
// length - retorna a quantidade de elementos dentro do objeto.
        let arr = [1, 2, 3, 4, 5]
        console.log(arr.length) // = 5
    }
    
function exEvery(){
// every() -  retorna um booleano se TODOS os índice do array passarem por uma verificação.
//            Recebe por parâmetro uma função responsável por fazer um teste em cada um dos elementos e retornar True, se todos os elementos forem true ou False se pelo menos um dos elementos for false.
        let arr = [1, 2, 3, 4, 5]
        arr.every(function (elemento, indice, objeto){})
//  essa função pode receber três parâmetros, o 'elemento' é obrigatório, os outros dois são opcionais.

//  elemento - é exatamento o valor de cada elemento 1, 2, 3, 4 ou 5.
//  indice - é a posição de cada elemento dentro do array. Ex: o elemento 1 tem indice 0 e o elemento 4 tem indice 3. (ver linha 13)
//  objeto - é uma cópia do próprio array. neste caso: (5) [1, 2, 3, 4, 5]

// Exemplo - Verificar se só existem números dentro do array (linha 27)
        let soNumeros = arr.every(function(el){
            return typeof el === 'number'
        })
        console.log(soNumeros) // = true
        // Neste caso, essa função reotornaria true já que todos os elementos são números. Se por acaso tivessemos (let array = ['junior', 1, 2, 3]) a função retornaria false já que existem uma string no índice 0.
    }

function exSome(){
// arr.some() - segue o mesmo raciocínio do .every() mas retorna true se PELO MENOS UM dos elementos retorna true durante a verificação.
// sendo assim:
        let arr = ['junior', 1, 2]
        let peloMenosUm = arr.some(function(el){
            return typeof el === 'number'
        })
        console.log(peloMenosUm) // = true
        //Aqui memso o array contento uma string, o método some retorna true já que a sua condição é que exista pelo menos um elemento verdadeiro na verificação.
}

function exFilter(){
// arr.filter() - Retorna um outro array contento apenas os elementos que retornarem true para o filtro.
// também recebe uma função como parâmetro(elemento, indice e objeto).
    let arr = ['junior', 1, 2, 'rafaella', 4, 'benjamin']
    let numeros = arr.filter(function(el){
        return typeof el === 'number'
    })
    console.log(numeros) // = (3) [1, 2, 4]
//Aqui o filter retorna um outro array contente apenas os elementos que são numeros (que retornaram true no filtro 'number').
}

function exForEach(){
// arr.forEach() -  É um método que executa um loop sem usar o for, while. Ele executa a função passada por parâmetro em cada item do array.
    let arr = [1, 2, 3, 4]
    arr.forEach(function(el, i, arr){
        console.log('el=', el,' | i=', i, ' | arr - ', arr.toString())
    })

// console.log =
/*  el = 1 | i = 0 | arr - 1, 2, 3, 4
    el = 2 | i = 1 | arr - 1, 2, 3, 4
    el = 3 | i = 2 | arr - 1, 2, 3, 4
    el = 4 | i = 3 | arr - 1, 2, 3, 4 */

}

function exIndexOfeLastIndexOf(){
// Esse método funciona da mesma forma que o metodo para strings.
// retornam a primeira posição do elemento buscado dentro do array.
    let arr = ['a', 1,'a', 2, 'b', 4, 'b']
    let posicao1 = arr.indexOf('b'/*, 5 */ ) // também podemos passar um segundo parâmetro nesse método, sendo esse número o indice pelo qual seria iniciado a busca. neste casa seria feita apartir do indice 2, não buscando no 0 e no 1.
    console.log(posicao1) // = 4 | com o segundo parâmetro retornaria = 6

    let posicao2 = arr.lastIndexOf('a'/*, 2*/)
    console.log(posicao2) // = 2 | com o segundo parâmetro retornaria = 1
// com 'lastIndexOf' a busca começa a ser feita do ultimo indice até o primeiro, retornando a primeira ocorrência encontrada.
//também recebe um segundo parâmetro, sendo o indice pelo qual queremos começar a busca.
}

function exMap(){
// Interage com cada um dos elementos e faz uma alteração em cada um retornando o novo valor para a mesma posição.
    let arr = [10, 4, 6, 9, 3]
    arr = arr.map(function(el, i){
        return el * i
    })
    console.log(arr) // = [0, 4, 12, 27, 12]
}
 function exConcat(){
// Serve para juntar arrays, com outras arrays e com outros elementos desejado (strings, números). Pode receber arrays, strings e números de uma vez só e retornará um novo array com todos os elementos.
    let mix = ['junior', 5, 9]
    let numeros = [8, 4, 2]
    let strings = ['olá', 'mundo']

    let concat = mix.concat(numeros, strings, 'novaString', 35)
    console.log(concat) // = ['junior', 5, 9, 8, 4, 2, 'olá', 'mundo', 'novaString', 35] (nova array)
 }

function exJoin(){
// join serve para transformar um array em uma string. semelhante ao método 'toString()', mas no caso do 'join()' é possivel passar um elemento separador por parâmento diferente da vírgula (que é o padrão).
    let arr = [1, 'olá', 5, 8, 'Mundo', 25]

    let padrao = arr.join()
    console.log(padrao)

    let diferente = arr.join(' -- ')
    console.log(diferente)
}

function exReduce(){
// Esse método retorna a soma dos elementos dentro do array, sem a necessidade de um loop explicito.
    let arr = [8, 4, 13, 27, 3]
// O 1º parâmetro do reduce é uma função, na qual: 
    // o primeiro parâmetro é o valor antes da soma no loop de cada elemento.
    // o segundo é o valor do proximo elemento.
    // a soma dos dois é o número que se torna o argumento do parametro 'anterior' no próximo loop.

console.log('----------') 

    let somaDoArr = arr.reduce(function(anterior, atual){
        console.log('anterior: ' + anterior + ' | atual: ' + atual + ' | soma: ' + (anterior+atual))
        return anterior + atual
    },/*10*/)
    console.log(arr)
    console.log(somaDoArr)

// o reduce() pode receber um segundo parâmetro que é um número inicial da soma antes de qualquer interação com os elementos.

console.log('----------') 

// também funciona com strings
    let arrString = ['olá ', 'Mundo ', 'Bem ', 'Vindo ']
    let somaString = arrString.reduce(function(i, a){
        console.log('anterio: ' + i + ' | atual: ' + a + ' | soma: ' + (i+a))
        return i + a
    })
    console.log(somaString)

console.log('----------') 

// reduceRight() - forma para iniciar a soma da direita para a esquerda.
let reduceRight = arrString.reduceRight(function(i, a){
        console.log('anterior: ' + i + ' | atual: ' + a + ' | soma: ' + (i+a))
        return i + a
    })
    console.log(reduceRight)

}

function exSlice(){
// retorna uma parte do array conforme solicitado pelos argumentos
    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    let novoSlice = arr.slice(2) // passando apenhas 1 argumento o slice vai até o final do array (posição length-1). aqui o '2' é a posição e não o indice, e a posição inicial não é contadada o slice começa a partir (no proximo elemento) dele.
    console.log(novoSlice) // = [2, 3, 4, 5, 6, 7, 8, 9, 10]

    let outroSlice = arr.slice(2, 6) //passando 2 argumentos o slice começa apartir do 2 (no 3º) e inclui o ultimo.
    console.log(outroSlice) // = [2, 3, 4, 5]
}




// Os métodos anteriores não alteram o array principal, retornando um novo array com a solicitação do método.
// Os próximos métodos são métodos destrutivos, uma vez que a sua utilização altere o array original ao qual está destinado.

function exDestrutivos(){
    let arr = [5, 10, 2]
    console.log('Original: ')
    console.log(arr)
// push() - adiciona um novo elemento como último índice do array.
    let push = arr.push('novo', 'push')
    console.log('Método push: ')
    console.log(push) // o retorno desse método é o novo LENGTH do array, sendo assim o que está armazenado na variavel push é o número 5.
    console.log('Array depois do push: ')
    console.log(arr)

// pop() - Remove (modificando o original) o último elemento do array e retorna-o para quem o chamou. 
    let ultimoItem = arr.pop()
    console.log('pop(remove último elemento): ')
    console.log(ultimoItem)
    console.log('Array depois do pop: ')
    console.log(arr)

// shift() - semelhante ao pop, mas ao invés de remover o último ele vai remover o primeiro elemento do array.
    let primeiroItem = arr.shift()
    console.log('shift(remove primeiro elemento): ')
    console.log(primeiroItem)
    console.log('Array depois do shift: ')
    console.log(arr)

// unshift() - semelhante ao push(), mas acrescenta um elemento no ínicio do array.
    let unshift = arr.unshift('novo', 'unshift')
    console.log('Método unshift: ')
    console.log(unshift) // também retorno e armazena o novo LENGTH do array.
    console.log('Array depois do unshift: ')
    console.log(arr)
}

function exReverse(){
// Inverte o array, o ultimo elemento se torna o primeiro e o primeiro o ultimo.
    let arr = [1, 2, 3, 4, 5]
    let newArray = arr.reverse()
    console.log(arr)
    console.log(newArray)
// como podemos ver nos console.log's mesmo criando uma nova variavel para armazenar o reverse, esse método sempre modifica o array original.
}

function exSplice(){
// incluir e excluir elementos em qualquer posição do array.
// esse método recebe 3 argumentos:
// 1º - é a posição onde ele deve iniciar a modificação
// 2º - é o numéro de elementos que ele deve excluir (0 se não quiser excluir itens).
// 3º - a partir daqui são os elementos que devem ser incluidos no array original (podendo ser quantos quiser).

    let arr = [10, 5, 16, 21, 8]
    let splice = arr.splice(2, 0, 'splice')
    console.log(arr)
    console.log(splice)

// esse método retorna os itens excluidos e modifica o array original.

}

    </script>


</body>
</html>